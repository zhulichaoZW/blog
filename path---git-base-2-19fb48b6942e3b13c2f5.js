webpackJsonp([44944857863777],{786:function(e,t){e.exports={data:{post:{id:"/Users/zhulichao/Documents/zhulichao_self/gatsby-blog/content/posts/2018-05-04--git-base2/index.md absPath of file >>> MarkdownRemark",html:'<h2>git diff</h2>\n<p>工作区：就是你在电脑里能看到的目录\n暂存区：git add 是把文件到暂存区\n本地仓库：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库</p>\n<p>git diff 进行对比时不会对比新创建的文件。</p>\n<p><code class="language-text">git diff branchName</code> 比较当前分支与 branchName 分支\n<code class="language-text">git diff branchName1 branchName2</code> 比较 branchName1 分支与 branchName2 分支\n<code class="language-text">git diff develop origin/develop</code>  比较本地 develop 分支和远程 develop 分支的差别\n<code class="language-text">git diff --staged</code>  比较暂存区与 HEAD\n<code class="language-text">git diff HEAD</code> 比较工作区与 HEAD\n<code class="language-text">git diff</code> 比较工作区与暂存区</p>\n<h2>git commit</h2>\n<ul>\n<li>\n<p><code class="language-text">git commit</code>  提交所有添加到索引库中、或从索引库删除的文件\n输入 i 进入编辑状态，第一行添加的内容作为 summary 描述, 隔一个空行，再添加的内容作为 description 描述，按 esc 退出编辑状态，输入 shift + :，输入 wq，保存并提交。</p>\n</li>\n<li>\n<p><code class="language-text">git commit -m &quot;summary 描述&quot;</code>  提交所有添加到索引库中、或从索引库删除的文件\n简化版提交命令，-m 添加 summary 描述，不能添加 description 描述。</p>\n</li>\n<li>\n<p><code class="language-text">git commit -a</code>  提交所有已在索引库中发生了修改的文件，新添加的文件不会被提交\n输入 i 进入编辑状态，第一行添加的内容作为 summary 描述, 隔一个空行，再添加的内容作为 description 描述，按 esc 退出编辑状态，输入 shift + :，输入 wq，保存并提交。</p>\n</li>\n<li>\n<p><code class="language-text">git commit --fixup [commitId]</code>  提交所有添加到索引库中、或从索引库删除的文件\n提交一个新的 commit，summay 为指定 commitId 的 summay 添加了 “fixup!” 前缀。在执行 <code class="language-text">rebase --autosquash</code> 命令时针对该次 commit 的操作默认为 fixup，本次提交信息会被清除，不会进入编辑提交信息的状态。</p>\n</li>\n<li>\n<p><code class="language-text">git commit --squash [commitId]</code>  提交所有添加到索引库中、或从索引库删除的文件\n提交一个新的 commit，summay 为指定 commitId 的 summay 添加了 squash!” 前缀。在执行 <code class="language-text">rebase --autosquash</code> 命令时针对该次 commit 的操作默认为 squash，会进入编辑提交信息的状态。</p>\n</li>\n</ul>\n<h2>git rebase</h2>\n<p>类似于 git merge，将指定分支合并到当前分支。区别是 git merge 会创建一次新的提交记录，git rebase 不会，它会把当前分支里的每个提交取消掉，并且把它们临时保存为补丁(这些补丁放到”.git/rebase”目录中)，然后把当前分支更新为最新的指定分支，最后再把保存的这些补丁应用到当前分支上。</p>\n<p>“-i” 是指交互模式，就是说你可以干预 rebase 这个事务的过程，包括设置 commit message，删除 commit 等等。\n“—autosquash” 是自动合并 commit 的参数。</p>\n<p><code class="language-text">git rebase -i --autosquash [branchName]</code> 当前在特性分支上执行，合并 branchName 分支到当前分支</p>\n<p><code class="language-text">git rebase -i --autosquash [branchName] [feature]</code> 无需在特性分支上执行</p>\n<p><code class="language-text">git rebase --abort</code> 终止 rebase 的行动，回到 rebase 前的状态</p>\n<p>特性分支合并了最新的主分支后，原有的 commit 是逐个应用到当前分支的，当正常执行的 commit 与已有代码发生冲突时，需执行下面三部，直到 rebase 成功。</p>\n<p>① 解决冲突</p>\n<p>② <code class="language-text">git add .</code></p>\n<p>③ <code class="language-text">git rebase --continue</code></p>\n<h2>git hooks</h2>\n<ul>\n<li><code class="language-text">pre-commit</code> 在键入提交信息前运行，被用来检查即将提交的快照，当从该挂钩返回非零值时，Git 放弃此次提交，但可以用 git commit —no-verify 来忽略</li>\n<li><code class="language-text">prepare-commit-msg</code> 在提交信息编辑器显示之前，默认信息被创建之后运行，该挂钩对通常的提交来说不是很有用，只在自动产生默认提交信息的情况下有作用，如提交信息模板、合并、压缩和修订提交等</li>\n<li><code class="language-text">commit-msg</code> 接收一个参数，此参数是包含最近提交信息的临时文件的路径，如果该挂钩脚本以非零退出，Git 放弃提交，可以用来在提交通过前验证项目状态或提交信息</li>\n<li><code class="language-text">post-commit</code> 挂钩在整个提交过程完成后运行，作为通知之类使用的</li>\n<li><code class="language-text">pre-rebase</code> 在衍合前运行，脚本以非零退出可以中止衍合的过程，可以使用这个挂钩来禁止衍合已经推送的提交对象</li>\n<li><code class="language-text">post-rewrite</code> 被那些会替换提交记录的命令调用，如 git commit —amend 和 git rebase</li>\n<li><code class="language-text">post-checkout</code> git checkout 成功运行后，该挂钩会被调用，可以用来为你的项目环境设置合适的工作目录</li>\n<li><code class="language-text">post-merge</code> 在merge命令成功执行后，该挂钩会被调用，可以用来在 Git 无法跟踪的工作树中恢复数据</li>\n<li><code class="language-text">pre-push</code> 会在 git push 运行期间，更新了远程引用但尚未传送对象时被调用，可以在推送开始之前，用它验证对引用的更新操作</li>\n</ul>\n<p><code class="language-text">cd .git/hooks</code> 可查看 git 所有 hooks</p>\n<h2>git fork 机制</h2>\n<p>使用场景：如果想要修改他人 github 的项目，直接 clone 代码到本地是不能 pull 或 push 的，所以要使用 fork，先把他人代码 fork 到自己的 github 仓库，然后 clone 到本地修改，然后再提交到自己 github 仓库，这时候想要把修改的代码提交给他人的话，就可以在自己的 github 上提交 pull request，等其他人看到后就可以把代码做一个合并。当他人的代码有更新的时候，也可以将更新同步到自己的 github 仓库。</p>\n<h4>github 的 fork</h4>\n<p>在 github 上，fork 一个项目，如 lodash，如果远程有更新，红框内会有提示，点击 Pull request，base fork 选则本地仓库，head fork 选则 lodash 仓库，可将 lodash 的更新通过一个 pull request 合并到自己的仓库中。也可以通过交换 base fork 和 head fork 提交一个 pull request 到 lodash 仓库。</p>\n<p>{% img <a href="https://zhulichao.github.io/2018/05/04/git-base2/fork-1.png">https://zhulichao.github.io/2018/05/04/git-base2/fork-1.png</a> fork 一个项目 %}</p>\n<p>{% img <a href="https://zhulichao.github.io/2018/05/04/git-base2/fork-2.png">https://zhulichao.github.io/2018/05/04/git-base2/fork-2.png</a> 提交 pull request %}</p>\n<p>{% img <a href="https://zhulichao.github.io/2018/05/04/git-base2/fork-3.png">https://zhulichao.github.io/2018/05/04/git-base2/fork-3.png</a> git remote -v %}</p>\n<h4>git 命令</h4>\n<p>在 github 创建一个仓库命名为 local-lodash 后，执行下面操作：\n<code class="language-text">git clone https://github.com/lodash/lodash.git local-lodash</code> 克隆远程 lodash 仓库到本地\n<code class="language-text">git remote remove origin</code> 删除远程仓库地址\n<code class="language-text">git remote add origin https://github.com/zhulichao/local-lodash.git</code> 添加自己的远程仓库地址\n<code class="language-text">git remote add upstream https://github.com/lodash/lodash.git</code> 添加上游远程仓库地址\n<code class="language-text">git push -u origin master</code> 初次提交到自己的远程仓库\n<code class="language-text">git pull upstream master</code> 同步上游仓库 lodash 的更新\n<code class="language-text">git push origin</code> 提交到自己的远程仓库\n<code class="language-text">git remote -v</code>  查看远程仓库地址，pull 和 push 可以是两个不同的地址</p>\n<p>{% img <a href="https://zhulichao.github.io/2018/05/04/git-base2/fork-4.png">https://zhulichao.github.io/2018/05/04/git-base2/fork-4.png</a> git remote -v %}</p>\n<p>这种方式与在 github 上执行 fork 还是有区别的，如图所示，没有上面图片中红框中的内容，在 github 上是无法通过 pull request 同步远程 lodash 更新的，当然也不能提交 pull request 到远程 lodash，只能通过上面的命令 <code class="language-text">git pull upstream master</code> 同步远程 lodash 的更新。如果你恰好也是远程 lodash 的贡献者，也可以通过 <code class="language-text">git push upstream master</code> 直接提交 commit 到 远程 lodash。</p>\n<p>{% img <a href="https://zhulichao.github.io/2018/05/04/git-base2/fork-5.png">https://zhulichao.github.io/2018/05/04/git-base2/fork-5.png</a> github 上查看 %}\n{% img <a href="https://zhulichao.github.io/2018/05/04/git-base2/fork-6.png">https://zhulichao.github.io/2018/05/04/git-base2/fork-6.png</a> 提交 pull request %}</p>',htmlAst:{type:"root",children:[{type:"element",tagName:"h2",properties:{},children:[{type:"text",value:"git diff"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"工作区：就是你在电脑里能看到的目录\n暂存区：git add 是把文件到暂存区\n本地仓库：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"git diff 进行对比时不会对比新创建的文件。"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"git diff branchName"}]},{type:"text",value:" 比较当前分支与 branchName 分支\n"},{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"git diff branchName1 branchName2"}]},{type:"text",value:" 比较 branchName1 分支与 branchName2 分支\n"},{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"git diff develop origin/develop"}]},{type:"text",value:"  比较本地 develop 分支和远程 develop 分支的差别\n"},{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"git diff --staged"}]},{type:"text",value:"  比较暂存区与 HEAD\n"},{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"git diff HEAD"}]},{type:"text",value:" 比较工作区与 HEAD\n"},{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"git diff"}]},{type:"text",value:" 比较工作区与暂存区"}]},{type:"text",value:"\n"},{type:"element",tagName:"h2",properties:{},children:[{type:"text",value:"git commit"}]},{type:"text",value:"\n"},{type:"element",tagName:"ul",properties:{},children:[{type:"text",value:"\n"},{type:"element",tagName:"li",properties:{},children:[{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"git commit"}]},{type:"text",value:"  提交所有添加到索引库中、或从索引库删除的文件\n输入 i 进入编辑状态，第一行添加的内容作为 summary 描述, 隔一个空行，再添加的内容作为 description 描述，按 esc 退出编辑状态，输入 shift + :，输入 wq，保存并提交。"}]},{type:"text",value:"\n"}]},{type:"text",value:"\n"},{type:"element",tagName:"li",properties:{},children:[{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:'git commit -m "summary 描述"'}]},{type:"text",value:"  提交所有添加到索引库中、或从索引库删除的文件\n简化版提交命令，-m 添加 summary 描述，不能添加 description 描述。"}]},{type:"text",value:"\n"}]},{type:"text",value:"\n"},{type:"element",tagName:"li",properties:{},children:[{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"git commit -a"}]},{type:"text",value:"  提交所有已在索引库中发生了修改的文件，新添加的文件不会被提交\n输入 i 进入编辑状态，第一行添加的内容作为 summary 描述, 隔一个空行，再添加的内容作为 description 描述，按 esc 退出编辑状态，输入 shift + :，输入 wq，保存并提交。"}]},{type:"text",value:"\n"}]},{type:"text",value:"\n"},{type:"element",tagName:"li",properties:{},children:[{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"git commit --fixup [commitId]"}]},{type:"text",value:"  提交所有添加到索引库中、或从索引库删除的文件\n提交一个新的 commit，summay 为指定 commitId 的 summay 添加了 “fixup!” 前缀。在执行 "},{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"rebase --autosquash"}]},{type:"text",value:" 命令时针对该次 commit 的操作默认为 fixup，本次提交信息会被清除，不会进入编辑提交信息的状态。"}]},{type:"text",value:"\n"}]},{type:"text",value:"\n"},{type:"element",tagName:"li",properties:{},children:[{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"git commit --squash [commitId]"}]},{type:"text",value:"  提交所有添加到索引库中、或从索引库删除的文件\n提交一个新的 commit，summay 为指定 commitId 的 summay 添加了 squash!” 前缀。在执行 "},{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"rebase --autosquash"}]},{type:"text",value:" 命令时针对该次 commit 的操作默认为 squash，会进入编辑提交信息的状态。"}]},{type:"text",value:"\n"}]},{type:"text",value:"\n"}]},{type:"text",value:"\n"},{type:"element",tagName:"h2",properties:{},children:[{type:"text",value:"git rebase"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"类似于 git merge，将指定分支合并到当前分支。区别是 git merge 会创建一次新的提交记录，git rebase 不会，它会把当前分支里的每个提交取消掉，并且把它们临时保存为补丁(这些补丁放到”.git/rebase”目录中)，然后把当前分支更新为最新的指定分支，最后再把保存的这些补丁应用到当前分支上。"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"“-i” 是指交互模式，就是说你可以干预 rebase 这个事务的过程，包括设置 commit message，删除 commit 等等。\n“—autosquash” 是自动合并 commit 的参数。"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"git rebase -i --autosquash [branchName]"}]},{type:"text",value:" 当前在特性分支上执行，合并 branchName 分支到当前分支"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"git rebase -i --autosquash [branchName] [feature]"}]},{type:"text",value:" 无需在特性分支上执行"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"git rebase --abort"}]},{type:"text",value:" 终止 rebase 的行动，回到 rebase 前的状态"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"特性分支合并了最新的主分支后，原有的 commit 是逐个应用到当前分支的，当正常执行的 commit 与已有代码发生冲突时，需执行下面三部，直到 rebase 成功。"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"① 解决冲突"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"② "},{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"git add ."}]}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"③ "},{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"git rebase --continue"}]}]},{type:"text",value:"\n"},{type:"element",tagName:"h2",properties:{},children:[{type:"text",value:"git hooks"}]},{type:"text",value:"\n"},{type:"element",tagName:"ul",properties:{},children:[{type:"text",value:"\n"},{type:"element",tagName:"li",properties:{},children:[{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"pre-commit"}]},{type:"text",value:" 在键入提交信息前运行，被用来检查即将提交的快照，当从该挂钩返回非零值时，Git 放弃此次提交，但可以用 git commit —no-verify 来忽略"}]},{type:"text",value:"\n"},{type:"element",tagName:"li",properties:{},children:[{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"prepare-commit-msg"}]},{type:"text",value:" 在提交信息编辑器显示之前，默认信息被创建之后运行，该挂钩对通常的提交来说不是很有用，只在自动产生默认提交信息的情况下有作用，如提交信息模板、合并、压缩和修订提交等"}]},{type:"text",value:"\n"},{type:"element",tagName:"li",properties:{},children:[{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"commit-msg"}]},{type:"text",value:" 接收一个参数，此参数是包含最近提交信息的临时文件的路径，如果该挂钩脚本以非零退出，Git 放弃提交，可以用来在提交通过前验证项目状态或提交信息"}]},{type:"text",value:"\n"},{type:"element",tagName:"li",properties:{},children:[{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"post-commit"}]},{type:"text",value:" 挂钩在整个提交过程完成后运行，作为通知之类使用的"}]},{type:"text",value:"\n"},{type:"element",tagName:"li",properties:{},children:[{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"pre-rebase"}]},{type:"text",value:" 在衍合前运行，脚本以非零退出可以中止衍合的过程，可以使用这个挂钩来禁止衍合已经推送的提交对象"}]},{type:"text",value:"\n"},{type:"element",tagName:"li",properties:{},children:[{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"post-rewrite"}]},{type:"text",value:" 被那些会替换提交记录的命令调用，如 git commit —amend 和 git rebase"}]},{type:"text",value:"\n"},{type:"element",tagName:"li",properties:{},children:[{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"post-checkout"}]},{type:"text",value:" git checkout 成功运行后，该挂钩会被调用，可以用来为你的项目环境设置合适的工作目录"}]},{type:"text",value:"\n"},{type:"element",tagName:"li",properties:{},children:[{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"post-merge"}]},{type:"text",value:" 在merge命令成功执行后，该挂钩会被调用，可以用来在 Git 无法跟踪的工作树中恢复数据"}]},{type:"text",value:"\n"},{type:"element",tagName:"li",properties:{},children:[{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"pre-push"}]},{type:"text",value:" 会在 git push 运行期间，更新了远程引用但尚未传送对象时被调用，可以在推送开始之前，用它验证对引用的更新操作"}]},{type:"text",value:"\n"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"cd .git/hooks"}]},{type:"text",value:" 可查看 git 所有 hooks"}]},{type:"text",value:"\n"},{type:"element",tagName:"h2",properties:{},children:[{type:"text",value:"git fork 机制"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"使用场景：如果想要修改他人 github 的项目，直接 clone 代码到本地是不能 pull 或 push 的，所以要使用 fork，先把他人代码 fork 到自己的 github 仓库，然后 clone 到本地修改，然后再提交到自己 github 仓库，这时候想要把修改的代码提交给他人的话，就可以在自己的 github 上提交 pull request，等其他人看到后就可以把代码做一个合并。当他人的代码有更新的时候，也可以将更新同步到自己的 github 仓库。"}]},{type:"text",value:"\n"},{type:"element",tagName:"h4",properties:{},children:[{type:"text",value:"github 的 fork"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"在 github 上，fork 一个项目，如 lodash，如果远程有更新，红框内会有提示，点击 Pull request，base fork 选则本地仓库，head fork 选则 lodash 仓库，可将 lodash 的更新通过一个 pull request 合并到自己的仓库中。也可以通过交换 base fork 和 head fork 提交一个 pull request 到 lodash 仓库。"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"{% img "},{type:"element",tagName:"a",properties:{href:"https://zhulichao.github.io/2018/05/04/git-base2/fork-1.png"},children:[{type:"text",value:"https://zhulichao.github.io/2018/05/04/git-base2/fork-1.png"}]},{type:"text",value:" fork 一个项目 %}"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"{% img "},{type:"element",tagName:"a",properties:{href:"https://zhulichao.github.io/2018/05/04/git-base2/fork-2.png"},children:[{type:"text",value:"https://zhulichao.github.io/2018/05/04/git-base2/fork-2.png"}]},{type:"text",value:" 提交 pull request %}"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"{% img "},{type:"element",tagName:"a",properties:{href:"https://zhulichao.github.io/2018/05/04/git-base2/fork-3.png"},children:[{type:"text",value:"https://zhulichao.github.io/2018/05/04/git-base2/fork-3.png"}]},{type:"text",value:" git remote -v %}"}]},{type:"text",value:"\n"},{type:"element",tagName:"h4",properties:{},children:[{type:"text",value:"git 命令"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"在 github 创建一个仓库命名为 local-lodash 后，执行下面操作：\n"},{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"git clone https://github.com/lodash/lodash.git local-lodash"}]},{type:"text",value:" 克隆远程 lodash 仓库到本地\n"},{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"git remote remove origin"}]},{type:"text",value:" 删除远程仓库地址\n"},{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"git remote add origin https://github.com/zhulichao/local-lodash.git"}]},{type:"text",value:" 添加自己的远程仓库地址\n"},{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"git remote add upstream https://github.com/lodash/lodash.git"}]},{type:"text",value:" 添加上游远程仓库地址\n"},{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"git push -u origin master"}]},{type:"text",value:" 初次提交到自己的远程仓库\n"},{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"git pull upstream master"}]},{type:"text",value:" 同步上游仓库 lodash 的更新\n"},{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"git push origin"}]},{type:"text",value:" 提交到自己的远程仓库\n"},{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"git remote -v"}]},{type:"text",value:"  查看远程仓库地址，pull 和 push 可以是两个不同的地址"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"{% img "},{type:"element",tagName:"a",properties:{href:"https://zhulichao.github.io/2018/05/04/git-base2/fork-4.png"},children:[{type:"text",value:"https://zhulichao.github.io/2018/05/04/git-base2/fork-4.png"}]},{type:"text",value:" git remote -v %}"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"这种方式与在 github 上执行 fork 还是有区别的，如图所示，没有上面图片中红框中的内容，在 github 上是无法通过 pull request 同步远程 lodash 更新的，当然也不能提交 pull request 到远程 lodash，只能通过上面的命令 "},{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"git pull upstream master"}]},{type:"text",value:" 同步远程 lodash 的更新。如果你恰好也是远程 lodash 的贡献者，也可以通过 "},{type:"element",tagName:"code",properties:{className:["language-text"]},children:[{type:"text",value:"git push upstream master"}]},{type:"text",value:" 直接提交 commit 到 远程 lodash。"}]},{type:"text",value:"\n"},{type:"element",tagName:"p",properties:{},children:[{type:"text",value:"{% img "},{type:"element",tagName:"a",properties:{href:"https://zhulichao.github.io/2018/05/04/git-base2/fork-5.png"},children:[{type:"text",value:"https://zhulichao.github.io/2018/05/04/git-base2/fork-5.png"}]},{type:"text",value:" github 上查看 %}\n{% img "},{type:"element",tagName:"a",properties:{href:"https://zhulichao.github.io/2018/05/04/git-base2/fork-6.png"},children:[{type:"text",value:"https://zhulichao.github.io/2018/05/04/git-base2/fork-6.png"}]},{type:"text",value:" 提交 pull request %}"}]}],data:{quirksMode:!1}},fields:{slug:"/git-base2/",prefix:"2018-05-04"},frontmatter:{title:"Git-基础2",subTitle:"关于 commit、rebase 使用，fork 机制",cover:{childImageSharp:{resize:{src:"/static/tool-d28a3acc9dc774d5cd1337942e3c2792-160fa.png"}}}}},author:{id:"/Users/zhulichao/Documents/zhulichao_self/gatsby-blog/content/parts/author.md absPath of file >>> MarkdownRemark",html:'<p><strong>朱立超</strong> Proin ornare ligula eu tellus tempus elementum. Aenean <a href="/">bibendum</a> iaculis mi, nec blandit lacus interdum vitae. Vestibulum non nibh risus, a scelerisque purus. :hearts:</p>'},footnote:{id:"/Users/zhulichao/Documents/zhulichao_self/gatsby-blog/content/parts/footnote.md absPath of file >>> MarkdownRemark",html:'<ul>\n<li>this is a demo site of the <a href="https://github.com/greglobinski/gatsby-starter-personal-blog">gatsby-starter-personal-blog</a></li>\n<li>built by <a href="https://www.greglobinski.com">greg lobinski</a></li>\n<li>GatsbyJS, ReactJs, CSS in JS - <a href="https://dev.greglobinski.com">Front-end web development with Greg</a></li>\n<li>deliverd by <a href="https://www.netlify.com/">Netlify</a></li>\n<li>photos by <a href="https://unsplash.com">unsplash.com</a></li>\n</ul>'},site:{siteMetadata:{facebook:{appId:"6"}}}},pathContext:{slug:"/git-base2/"}}}});
//# sourceMappingURL=path---git-base-2-19fb48b6942e3b13c2f5.js.map